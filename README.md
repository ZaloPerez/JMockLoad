# JMockLoad

**JMockLoad** is a library meant to easily generate custom mock data. It doesn't uses any third party's libraries, just plain native Java code to keep things simple.

It is currently a beta I'm still working on, so beware! there will be dragons! **It might be compatible only with Java 24 projects**.

## How does it work?

Simple! The short summary is that it generates a List of objects of your choice with null or autogenerated values. But the cool thing is that you can define how those values are generated by attaching generators and constraints to the fields of the class! You can emulate a database call with a fixed amount of result elements following your table's constraints and test stuff with them with no real database connection! You can even set a delay in ms to emulate the data retrieval times and test performance stuff!

## How can I test it?

First you need to instantiate the JMockLoad core class by ussing its main constructor, **JMockLoad(Class<T> clazz, int size)**, which requires a Class and the size of the list you want to create.
Then you just need to instantiate a List of the predefinded objects with the **JMockLoad.execute()** method, and you will generate as many object as you told to the JMockLoad's constructor. Those objects will have null values in all their fields.

## How can I generate the values of a field?

JMockLoad has the .configure(String fieldname) method, which lets you configure the generation conditions of the field with that exact name. You can chain 3 different methods to the .configure(String fieldname) one: .generator(ValueGenerator<?> generator), .constraint(FieldConstraint constraint), .constraints(FieldConstraint... constraints) and .apply().

* **.generator(ValueGenerator<?> generator)**

You can pick any of the generator provided inside the es.gonzagile.jmockload.generators package. There are dumb generators and smart generators: dumb generators have close to none logic, most of them just generate random or sequential values based on the list position of each object. You can also set a fixed value using the FixedValueGenerator.

* **.generator(ValueGenerator<?> generator)** and **.constraint(FieldConstraint constraint)**

You can pick none, one or many of the constraints inside es.gonzagile.jmockload.constraints package. Those constraints are meant to be used by smart generators and let you set the rules of the values generated(for example, the chars, length range and suffix of a String).

* **.apply()**

This is the closure method for the configuration. All the .configure(String fieldname) chains must end with .apply().

## Pre requisites

*The objects to be generated must comply with the next rules at this moment:
1. It must be a class, not a record, enum, interface nor annotation.
2. It must have a public constructor with no params.
3. At the moment there are no custom generators nor constraints, so you need to stick with the ones availables(String, Integer and Long at the moment). If there is no generator to a type, it will always be null.
